HASH_FULLNESS_LOAD_FACTOR = 0.75


class HashSet:
    """
    This class shows you how the `set` class is implemented in Python.
    It is more like a map instead of a seq (although it might look like it).
    """

    class __Placeholder:
        """
        Unlike the simple/singly linked list, which its deletion only requires
        shifting the each node's property `next`, hash set would require extra
        handling.

        If the value to be delete is in ??, it should be replaced with ??
        - the end       `None`
        - the middle    `__Placeholder` (not cutting the chain of values)
        """

        def __init__(self):
            pass

        def __eq__(self, other):
            return False

    def __init__(self, contents=[]):
        """
        We store items by the computed index using `hash` function.
        """
        self.items = [None] * 10
        self.num_items = 0

        for element in contents:
            self.add(element)

    @staticmethod
    def __add(item, items):
        """
        The problem of using hashed values as indices
        - values generated by `hash()` might be extremely big (e.g. billions)
        - the list/seq/set are finite and its size can't be as big as the hash

        So we came up a (imperfect) solution: HASH % LEN(LIST)
        - collision         take 10, 16 as an example, both got a 1 after %5
        - how to avoid it   #TODO clarify needed
        """
        idx = hash(item) % len(items)

        # TODO document this (maybe it's related to 'avoiding hash collision')
        location = -1

        # This while loop mainly serves to solve the problem of hash collision.
        #   it advance to the next location in the list to see if THAT location
        #   might be available (cond: None or None-alike, term: Linear Probing)
        while items[idx] is not None:

            # `item` already in the set
            if items[idx] == item:
                return False

            # TODO document this
            if location < 0 and type(items[idx]) == HashSet.__Placeholder:
                location = idx

            # TODO document this
            idx = (idx + 1) % len(items)

        # TODO document this
        if location < 0:
            location = idx

        # the main idea is saving/mapping ITEM(value) to a KEY(HASH % LEN)
        items[location] = item

        return True

    @staticmethod
    def __remove(item, items):
        idx = hash(item) % len(items)

        # TODO walk through this
        while items[idx] is not None:
            if items[idx] == item:
                next_idx = (idx + 1) % len(items)

                if items[next_idx] is None:
                    items[idx] = None
                else:
                    items[idx] = HashSet.__Placeholder()

                return True

            idx = (idx + 1) % len(items)

        return False

    @staticmethod
    def __rehash(old_list, new_list):
        """
        This method serves to retain the complexity of ADD to O(1) by ensuring
        that the slot/bucket/set-list is never full OR almost-full

        The reason for doing this, imagine WHEN
        1. there's only 1 slot/bucket/set-list open -> search the entire list
        2. the slot/bucket/set-list are full        -> infinite loop (?why)
        """
        for item in old_list:
            if item is not None and type(item) != HashSet.__Placeholder:
                HashSet.__add(item, new_list)

    def add(self, item):
        """
        O(1)

        The core functionality for `add` is merely 3 to 6 lines, as for the
        rest of them, they are trying to prevent certain issues from happening
        in the future, like hash collision OR dynamically balancing the hash
        set according to the load factor to retain a O(1) `add` (like `append`
        for list, but unordered).
        """
        if HashSet.__add(item, self.items) is True:
            self.num_items += 1

            load = self.num_items / len(self.items)
            if load >= HASH_FULLNESS_LOAD_FACTOR:
                # TODO walk through this
                self.items = HashSet.__rehash(
                    self.items, [None] * 2 * len(self.items)
                )

    def remove(self, item):
        """
        O(1)

        Almost the same as method `discard`, it'd not need the part of raising
        exceptions when the key/item specified is not a member of the hashset.
        """
        if HashSet.__remove(item, self.items) is True:
            self.num_items -= 1

            load = max(self.num_items, 10) / len(self.items)
            if load <= 1 - HASH_FULLNESS_LOAD_FACTOR:
                # TODO walk through this
                self.items = HashSet.__rehash(
                    self.items, [None] * int(len(self.items) / 2)
                )
        else:
            raise KeyError("Item not in HashSet")

    def discard(self, item):
        """
        O(1)

        No exception would be raised if the key/item isn't a member of the set.
        """
        if HashSet.__remove(item, self.items) is True:
            self.num_items -= 1

            load = max(self.num_items, 10) / len(self.items)
            if load <= 1 - HASH_FULLNESS_LOAD_FACTOR:
                # TODO walk through this
                self.items = HashSet.__rehash(
                    self.items, [None] * int(len(self.items) / 2)
                )

    def __contains__(self, item):
        """
        O(1)
        """
        idx = hash(item) % len(self.items)

        while self.items[idx] is not None:
            if self.items[idx] == item:
                return True

            # TODO document this
            idx = (idx + 1) % len(self.items)

        return False

    def __getitem__(self, item):
        """
        O(?)

        This method is specifically written for the external `HashMap` to use.
        The `HashSet` class itself does NOT require this method to work.
        """
        idx = hash(item) % len(self.items)

        while self.items[idx] is not None:
            if self.items[idx] == item:
                return self.items[idx]

            # TODO document this
            idx = (idx + 1) % len(self.items)

        return None

    def __iter__(self):
        """
        O(?)
        """
        for idx in range(len(self.items)):
            if (
                self.items[idx] is not None
                and type(self.items[idx]) != HashSet.__Placeholder
            ):
                # TODO walk through this
                yield self.items[idx]

    def difference_update(self, other):
        """
        O(?)

        Mutating the original set, return None
        >>> set1 = {1, 3, 5}
        >>> set2 = {3, 4, 5}
        >>> set1.difference_update(set2) -> {1} # cuz 3,5 is in another list
        """
        for item in other:
            self.discard(item)

    def difference(self, other):
        """
        O(?)

        Does not mutate anything, return what sets would look like after it
        >>> set1 = {1, 3, 5}
        >>> set2 = {3, 4, 5}
        >>> set1.difference(set2)        -> {1} # cuz 3,5 is in another list
        """
        # make a new copy via `self` (an instance)
        result = HashSet(self)
        result.difference_update(other)

        return result


def main():
    pass


if "__main__" == __name__:
    main()
